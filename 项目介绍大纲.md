# 基于图卷积网络的商品推荐系统

## 幻灯片 1: 标题页
**标题：** 基于图卷积网络的商品推荐系统
**演讲者：** 徐明君

---

## 幻灯片 2: 推荐系统在生活中的应用
**内容：**
- 我们每天都在使用推荐系统
  - 淘宝/京东：猜你喜欢的商品
  - 抖音：推荐你可能感兴趣的视频
  - 网易云音乐：为你推荐可能喜欢的歌曲
  - B站：首页推荐视频

**关键问题：** 这些系统是如何知道你喜欢什么的？

---

## 幻灯片 3: 本项目要解决的问题
**场景：**
- 有一个电商平台，记录了用户购买过哪些商品
- 问题：如何给用户推荐他们还没买过，但可能会喜欢的商品？

**挑战：**
- 用户只会购买一小部分商品（数据非常稀疏）
- 我们没有评分数据，只知道"买过"或"没买过"
- 需要从这些有限的信息中找到规律

---

## 幻灯片 4: 我们的解决方案概述
**核心思想：**
- 把用户和商品的关系看成一个"社交网络"
- 通过图卷积网络（GCN）在这个网络上传播信息
- 使用BPR损失函数来学习用户的偏好

**两个核心技术：**
1. 图卷积网络（GCN）- 帮助我们理解用户和商品之间的关系
2. BPR损失函数 - 教会模型如何排序推荐

---

## 幻灯片 7: 图卷积网络（GCN）的核心思想
**关键理念：** 购买同一商品的人可能同类，一个人购买的多种商品也可能同类

**在社交网络中：** 你和你的朋友可能有相似的兴趣爱好
- 如果你的朋友都喜欢跑步，你也可能喜欢跑步
- 如果你关注的人都在讨论某部电影，你可能也会对它感兴趣

**在推荐系统中：**
- 如果一个商品被很多和你品味相似的用户购买，你也可能喜欢这个商品
- 如果一个用户购买的商品和你购买的商品相似，你可能也喜欢这个用户购买的其他商品

**GCN的作用：** 让信息在图上"流动"，每个节点会受到邻居节点的影响

---

## 幻灯片 8: GCN如何工作 - 嵌入向量
**什么是嵌入向量？**
- 可以把它想象成每个用户/商品的"特征指纹"
- 是一串数字（比如64个数字），表示这个用户/商品的特点
- 例如：`[0.2, -0.5, 0.8, ..., 0.1]` （共64个数）

**为什么需要嵌入向量？**
- 计算机无法直接理解"用户"和"商品"
- 需要把它们转换成数字，才能进行计算
- 相似的用户应该有相似的向量，相似的商品也应该有相似的向量

**初始化：**
- 一开始，我们给每个用户和商品随机分配一个向量
- 这些向量在训练过程中会不断调整，变得越来越有意义

---

## 幻灯片 9: GCN如何工作 - 信息传播
**图卷积的过程（通俗解释）：**

**第0层（初始状态）：**
- 每个用户和商品都有自己的初始向量

**第1层（听取邻居意见）：**
- 每个节点看看它的邻居都是什么样的
- 用户节点：聚合它购买过的所有商品的向量
- 商品节点：聚合购买过它的所有用户的向量
- 生成新的向量表示

**第2层（听取邻居的邻居）：**
- 继续聚合，信息传播得更远
- 现在能捕捉到"间接关系"

**第3层（更广范围）：**
- 再次聚合，覆盖更大范围的网络

**最终：**
- 把0层、1层、2层、3层的向量取平均
- 得到新的用户向量和商品向量

---

## 幻灯片 10: GCN的数学表达（简化版）
**核心公式：**
$$\textbf{v}_{x}=\frac{\sum_{x与y有连边}\textbf{v}_{y}}{n}$$

即新向量是所有邻居向量的**加权平均**

**具体来说：**
- 假设用户A购买过商品1、商品2、商品3
- 用户A的新向量 = (商品1向量 + 商品2向量 + 商品3向量) / 3
- 同时，每个商品也会根据购买过它的用户更新向量

**归一化技巧：**
- 为了防止有些节点的邻居太多，有些太少，我们会对每个节点的"影响力"进行归一化处理，确保每个节点的贡献都在合理范围内

**多层聚合：**
- 第1层：捕捉1步之内的邻居关系
- 第2层：捕捉2步之内的关系
- 第3层：捕捉3步之内的关系
- 最后取平均，综合不同层次的信息

---

## 幻灯片 11: GCN的优势
**为什么GCN对推荐系统有效？**

1. **捕捉高阶关系**
   - 不仅考虑直接交互，还考虑间接影响
   - 例如：用户A → 商品X → 用户B → 商品Y，发现Y可能适合A

2. **缓解数据稀疏**
   - 即使用户只购买过很少的商品
   - 通过图结构，可以从相似用户那里获得信息

3. **参数共享**
   - 所有节点使用相同的聚合规则
   - 减少需要学习的参数，不容易过拟合

---

## 幻灯片 13: BPR损失函数 - 基本思想
**BPR = Bayesian Personalized Ranking（贝叶斯个性化排序）**

**目标：**
- 让模型学会正确排序：用户更喜欢的商品应该排在前面

**如何实现？**
- 对于每个用户，我们采样两个商品：
  - 正样本：用户购买过的商品
  - 负样本：用户没购买过的商品
- 希望模型对正样本的评分 > 负样本的评分

**训练过程：**
- 如果模型预测正确（正样本分数高），损失小
- 如果模型预测错误（负样本分数高），损失大
- 通过不断调整，让模型的预测越来越准确

---

## 幻灯片 14: BPR损失函数 - 数学表达
**评分计算：**

用户 $u$ 对商品 $i$ 的评分为

$$R_{u,i}=\sigma(\textbf{u}\cdot \textbf{i})$$

- "·" 表示向量点积（两个向量对应位置相乘再相加）
- sigmoid函数表达式为 $\frac{1}{1+e^{-x}}$ ，它单调递增，值域在 $(0,1)$，用于压缩值域
- 分数越接近1，表示用户越可能喜欢这个商品

**BPR损失：**

$$\text{BPR\_loss}=-\log(\sigma(R_{u,i_-}-R_{u,i_+}))$$

**直观理解：**
- 如果正样本评分 > 负样本评分：损失很小（模型做得好）
- 如果正样本评分 < 负样本评分：损失很大（模型做错了）

---

## 幻灯片 15: 正则化 - 防止过拟合
**什么是过拟合？**
- 模型在训练数据上表现很好
- 但在新数据上表现很差
- 就像死记硬背，没有真正理解

**L2正则化的作用：**
- 限制嵌入向量不要太大
- 鼓励模型学习简单、通用的模式

**正则化损失：**

$$\text{REG\_loss}=\frac{\sum{\textbf{u}^2+\textbf{v}_+^2+\textbf{v}_-^2}}{2n}$$

**总损失：**

$$\text{TOT\_loss}=\text{BPR\_loss}+\lambda\cdot\text{REG\_loss}$$

- λ是一个很小的数（0.0001），控制正则化的强度

---

## 幻灯片 16: 训练流程总结
**完整的训练步骤：**

1. **数据准备**
   - 对于每个用户，采样一个正样本（购买过的商品）
   - 随机采样一个负样本（没购买过的商品）
   - 形成三元组：(用户, 正样本商品, 负样本商品)

2. **前向传播**
   - 通过GCN计算所有用户和商品的嵌入向量
   - 计算正样本和负样本的评分

3. **计算损失**
   - BPR损失：惩罚负样本评分高于正样本的情况
   - 正则化损失：防止过拟合

4. **反向传播**
   - 计算梯度（损失对每个参数的影响）
   - 更新参数

5. **迭代**
   - 重复以上步骤500轮（epochs）
   - 每10轮测试一次模型效果

---

## 幻灯片 17: 如何评估模型好不好？
**评估指标：**

**Recall（召回率）**
- 问题：在推荐的前20个商品中，有多少是用户真正喜欢的？
- 计算：(推荐列表中用户喜欢的商品数) / (用户喜欢的总商品数)
- 例如：用户喜欢5个商品，推荐了20个，其中3个命中 → Recall = 3/5 = 0.6

**Precision（精确率）**
- 问题：推荐的前20个商品中，有多少比例是用户真正喜欢的？
- 计算：(推荐列表中用户喜欢的商品数) / 20
- 例如：推荐20个，命中3个 → Precision = 3/20 = 0.15

**NDCG（归一化折损累积增益）**
- 考虑推荐顺序的质量
- 相关商品排在前面，分数更高
- 分数在0-1之间，越高越好

---

## 幻灯片 20: 模型的工作流程图
**从数据到推荐的完整流程：**

```
1. 输入数据
   ↓
2. 构建用户-商品二分图
   ↓
3. 初始化嵌入向量（用户 + 商品）
   ↓
4. GCN信息传播（3层）
   第1层：聚合1步邻居
   第2层：聚合2步邻居  
   第3层：聚合3步邻居
   ↓
5. 层聚合（取平均）
   ↓
6. 得到最终嵌入向量
   ↓
7. 计算评分（用户向量 · 商品向量）
   ↓
8. 训练阶段：使用BPR损失优化
   或
   推荐阶段：对所有商品排序，返回Top-20
```

---

## 幻灯片 25: 代码实现的关键部分
**三个核心函数：**

1. **`computer()` - GCN前向传播**
   - 输入：图结构 + 初始嵌入
   - 过程：多层图卷积 + 层聚合
   - 输出：最终的用户和商品嵌入

2. **`bpr_loss()` - BPR损失计算**
   - 输入：用户、正样本、负样本
   - 过程：计算评分差 + softplus
   - 输出：BPR损失 + 正则化损失

3. **`getUsersRating()` - 评分预测**
   - 输入：用户列表
   - 过程：向量点积 + sigmoid
   - 输出：用户对所有商品的评分

**训练循环：**
- 500轮迭代
- 每轮：采样 → 计算损失 → 更新参数
- 每10轮：在测试集上评估

---

## 幻灯片 28: 总结
**核心要点回顾：**

1. **问题：** 为用户推荐可能喜欢但还没购买过的商品

2. **方法：** 
   - 用图表示用户-商品关系
   - 用GCN学习嵌入向量
   - 用BPR损失优化排序

3. **GCN的作用：**
   - 在图上传播信息
   - 捕捉多步关系
   - 缓解数据稀疏

4. **BPR的作用：**
   - 学习正确的排序
   - 适合隐式反馈
   - 优化推荐质量

5. **效果评估：**
   - Recall：能找回多少用户喜欢的
   - Precision：推荐有多准确
   - NDCG：排序质量如何

---

## 幻灯片 30: 谢谢！
**感谢聆听！**

**项目信息：**
- GitHub: https://github.com/Lumine2024/recommend-GCN-missing.git

---

